<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>桃花扇</title>
    <url>/2021/04/15/My-New-Post/</url>
    <content><![CDATA[<h1 id="《哀江南》（节选）"><a href="#《哀江南》（节选）" class="headerlink" title="《哀江南》（节选）"></a>《哀江南》（节选）</h1><pre><code>            --- 清 孔尚任

俺曾见金陵玉殿莺啼晓，秦淮水榭花开早，谁知道容易冰消！
眼看他起朱楼，眼看他宴宾客，眼看他楼塌了！
这青苔碧瓦堆，俺曾睡风流觉，将五十年兴亡看饱。
那乌衣巷不姓王，莫愁湖鬼夜哭，凤凰台栖枭鸟。
残山梦最真，旧境丢难掉，不信这舆图换稿！
诌一套《哀江南》，放悲声唱到老。
</code></pre>
]]></content>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建博客</title>
    <url>/2021/04/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="搭建博客-Hexo-github-butterfly主题"><a href="#搭建博客-Hexo-github-butterfly主题" class="headerlink" title="搭建博客 (Hexo + github + butterfly主题)"></a>搭建博客 (Hexo + github + butterfly主题)</h1><h2 id="1、下载安装Nodejs"><a href="#1、下载安装Nodejs" class="headerlink" title="1、下载安装Nodejs"></a>1、下载安装Nodejs</h2><pre><code>node -v
npm -v
</code></pre>
<h2 id="2、安装淘宝镜像cnpm管理器"><a href="#2、安装淘宝镜像cnpm管理器" class="headerlink" title="2、安装淘宝镜像cnpm管理器"></a>2、安装淘宝镜像cnpm管理器</h2><pre><code>npm install -g cnpm --registry=http://registry.npm.taobao.org
cnpm -v
</code></pre>
<h2 id="3、安装hexo框架"><a href="#3、安装hexo框架" class="headerlink" title="3、安装hexo框架"></a>3、安装hexo框架</h2><pre><code>cnpm install -g hexo-cli
hexo -v
</code></pre>
<h2 id="4、安装git-若有github账号可直接跳过本条"><a href="#4、安装git-若有github账号可直接跳过本条" class="headerlink" title="4、安装git (若有github账号可直接跳过本条)"></a>4、安装git (若有github账号可直接跳过本条)</h2><p>git使用前配置：<br>    下载完git后，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p>
<pre><code>1、配置提交人姓名：git config --global user.name 提交人姓名
2、配置提交人姓名：git config --global user.email 提交人邮箱
3、查看git配置信息：git config --list
</code></pre>
<h2 id="5、使用hexo搭建博客-git-bash-shell-打开"><a href="#5、使用hexo搭建博客-git-bash-shell-打开" class="headerlink" title="5、使用hexo搭建博客 (git bash/shell 打开)"></a>5、使用hexo搭建博客 (git bash/shell 打开)</h2><h3 id="5-1-在指定位置创建文件夹，初始化hexo"><a href="#5-1-在指定位置创建文件夹，初始化hexo" class="headerlink" title="5.1 在指定位置创建文件夹，初始化hexo"></a>5.1 在指定位置创建文件夹，初始化hexo</h3><pre><code>mkdir blog  #创建blog目录
cd blog   #进入blog目录
hexo init  #生成博客 初始化博客
hexo s  /  hexo server  #启动本地博客服务
</code></pre>
<p> 初始化之后，ls -al 查看可得文件<br> _config.landscape.yml  db.json        package.json       public/     source/  yarn.lock<br> _config.yml  node_modules/  package-lock.json  scaffolds/  themes/ </p>
<p> 其中 _config.yml 是配置文件<br>      themes/     存放博客主题</p>
<h3 id="5-2-创建post"><a href="#5-2-创建post" class="headerlink" title="5.2 创建post"></a>5.2 创建post</h3><pre><code>hexo new &quot;我的第一篇博客文章&quot;

cd source/_posts
ls -al
可查看所有的.md文件
</code></pre>
<h3 id="5-3-编辑博客文章内容"><a href="#5-3-编辑博客文章内容" class="headerlink" title="5.3 编辑博客文章内容"></a>5.3 编辑博客文章内容</h3><pre><code>vim 我的第一篇博客文章.md

编写格式遵循markdown格式
</code></pre>
<h3 id="5-4-进入创建博客目录blog的主目录，执行清理工作，再执行生成工作"><a href="#5-4-进入创建博客目录blog的主目录，执行清理工作，再执行生成工作" class="headerlink" title="5.4 进入创建博客目录blog的主目录，执行清理工作，再执行生成工作"></a>5.4 进入创建博客目录blog的主目录，执行清理工作，再执行生成工作</h3><pre><code>ls   (查看在_posts目录)
cd ../..  
pwd 
hexo clean 
hexo g  /  hexo generate   #生成发布用的静态页面,存在public文件中

生成工作完成后，会出现目录 ......../我的第一篇博客文章/index.html
</code></pre>
<h3 id="5-5-重新启动"><a href="#5-5-重新启动" class="headerlink" title="5.5 重新启动"></a>5.5 重新启动</h3><pre><code>hexo s  
</code></pre>
<p>至此，博客仅在本地localhost:4000启动,但是若需要可被远程访问，<br>    接下来可部署到github来公开使用</p>
<h2 id="6、github创建博客仓库"><a href="#6、github创建博客仓库" class="headerlink" title="6、github创建博客仓库"></a>6、github创建博客仓库</h2><h3 id="6-1-进入github-创建Repository-空仓库"><a href="#6-1-进入github-创建Repository-空仓库" class="headerlink" title="6.1 进入github,创建Repository 空仓库"></a>6.1 进入github,创建Repository 空仓库</h3><pre><code>注意：Repository name 命名格式为 （owner）.github.io
必须是自己的github用户名.github.io

比如 ： 
    Owner : sjbhz
    Repository name : sjbhz.github.io
</code></pre>
<h3 id="6-2-进入command-bash窗口，在创建的blog目录下安装一个git-部署插件"><a href="#6-2-进入command-bash窗口，在创建的blog目录下安装一个git-部署插件" class="headerlink" title="6.2 进入command/bash窗口，在创建的blog目录下安装一个git 部署插件"></a>6.2 进入command/bash窗口，在创建的blog目录下安装一个git 部署插件</h3><pre><code>cnpm install --save hexo-deployer-git
</code></pre>
<h3 id="6-3-设置-config-yml配置文件"><a href="#6-3-设置-config-yml配置文件" class="headerlink" title="6.3 设置_config.yml配置文件"></a>6.3 设置_config.yml配置文件</h3><pre><code>vim _config.yml

_config.yml配置文件中：
    #Deployment
    ##Docs: https://hexo.io/docs/deployment.html
    deploy:
        type: git
        repo: https://github.com/sjbhz/sjbhz.github.io.git
        branch: master

配置好，保存退出
</code></pre>
<h3 id="6-4-将博客部署到远端"><a href="#6-4-将博客部署到远端" class="headerlink" title="6.4 将博客部署到远端"></a>6.4 将博客部署到远端</h3><pre><code>hexo deploy / hexo d
输入账号密码
</code></pre>
<h3 id="6-5-刷新创库，访问-sjbhz-github-io"><a href="#6-5-刷新创库，访问-sjbhz-github-io" class="headerlink" title="6.5 刷新创库，访问 sjbhz.github.io"></a>6.5 刷新创库，访问 sjbhz.github.io</h3><h2 id="7、更换主题"><a href="#7、更换主题" class="headerlink" title="7、更换主题"></a>7、更换主题</h2><pre><code>打开butterfly网站  https://butterfly.js.org/posts/21cfbf15/
</code></pre>
<h3 id="7-1-下载主题"><a href="#7-1-下载主题" class="headerlink" title="7.1 下载主题"></a>7.1 下载主题</h3><pre><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly
</code></pre>
<h3 id="7-2-修改配置"><a href="#7-2-修改配置" class="headerlink" title="7.2 修改配置"></a>7.2 修改配置</h3><p>   修改站點配置文件_config.yml，把主題改為butterfly</p>
<pre><code>_config.yml配置文件中：
    theme: butterfly
</code></pre>
<h3 id="7-3-进行清理，再重新生成，部署，再推送上传至github"><a href="#7-3-进行清理，再重新生成，部署，再推送上传至github" class="headerlink" title="7.3 进行清理，再重新生成，部署，再推送上传至github"></a>7.3 进行清理，再重新生成，部署，再推送上传至github</h3><pre><code>hexo clean 
hexo g
hexo s  
hexo deploy
</code></pre>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><pre><code>换主题时报 extends includes/layout.pug block content #recent-posts.recent-posts include includes/recent-posts.pug include includes/pagination.pug 
</code></pre>
<h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><h3 id="在hexo目录下打开git-bash，输入命令："><a href="#在hexo目录下打开git-bash，输入命令：" class="headerlink" title="在hexo目录下打开git bash，输入命令："></a>在hexo目录下打开git bash，输入命令：</h3><h3 id="npm-install-–save-hexo-renderer-jade-hexo-generator-feed-hexo-generator-sitemap-hexo-browsersync-hexo-generator-archive"><a href="#npm-install-–save-hexo-renderer-jade-hexo-generator-feed-hexo-generator-sitemap-hexo-browsersync-hexo-generator-archive" class="headerlink" title="npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive"></a>npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</h3><h2 id="8、Hexo增加搜索功能"><a href="#8、Hexo增加搜索功能" class="headerlink" title="8、Hexo增加搜索功能"></a>8、Hexo增加搜索功能</h2><h3 id="8-1-安装搜索：在Hexo的根目录下"><a href="#8-1-安装搜索：在Hexo的根目录下" class="headerlink" title="8.1 安装搜索：在Hexo的根目录下"></a>8.1 安装搜索：在Hexo的根目录下</h3><pre><code>npm install hexo-generator-searchdb --save
</code></pre>
<h3 id="8-2-全局配置文件-config-yml，新增"><a href="#8-2-全局配置文件-config-yml，新增" class="headerlink" title="8.2 全局配置文件_config.yml，新增"></a>8.2 全局配置文件_config.yml，新增</h3><pre><code>search:
    path: search.xml
    field: post
    format: html
    limit: 10000
</code></pre>
<h3 id="8-3-hexo主题配置文件（-themes-next-config-yml），修改local-search的enable为true"><a href="#8-3-hexo主题配置文件（-themes-next-config-yml），修改local-search的enable为true" class="headerlink" title="8.3 hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true"></a>8.3 hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true</h3><pre><code># Local search
# Dependencies: https://github.com/flashlab/hexo-generator-search
local_search:
    enable: true
    # if auto, trigger search by changing input
    # if manual, trigger search by pressing enter key or search button
    trigger: auto
    # show top n results per article, show all results by setting to -1
    top_n_per_article: 1
</code></pre>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据类型及常用方法</title>
    <url>/2021/04/21/04js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="js中六大数据类型及常用方法"><a href="#js中六大数据类型及常用方法" class="headerlink" title="js中六大数据类型及常用方法"></a>js中六大数据类型及常用方法</h1><pre><code>js有六种数据类型,其中5种基本数据类型(Number, String, Boolean, Undefined, Null), 1种复杂数据类型(Object)
</code></pre>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><pre><code>由于js 变量是松散类型的，所以它提供了一种检测当前变量数据类型的方法--typeof关键字

typeof 123              //Number
typeof &#39;abc&#39;            // String
typeof true             //Boolean
typeof undefined        //Undefined
typeod null             //Object   (因为null类型当作一个空对象引用)
typeof &#123;&#125;               //Object
typeof []               //Object
typeof console.log()    //Function
</code></pre>
<h2 id="1-Number类型"><a href="#1-Number类型" class="headerlink" title="1 Number类型"></a>1 Number类型</h2><pre><code>Number类型包括 整数 和 浮点数 2种
NaN 非数字类型
    特点: 1) 涉及到的任何关于NaN的操作，都会返回NaN;
          2) NaN不等于自身   
isNaN() 函数用于检查其参数是否是非数字值
</code></pre>
<h3 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h3><pre><code>new Number(value)   //返回一个新创建的 Number 对象
Number(value)       //把 Number() 作为一个函数来调用，把 value 转换成一个原始数值，并返回该值（若转换失败 则返回 NaN）

特别地： 
    var a = &quot;+100&quot;;
    alert( a+100 ); // &quot;100100&quot;
    alert(Number(a)); // 100 

    var a1=&quot;000100&quot;;
    alert(Number(a1));//100

    var a2 = &quot;&quot;;   // &quot;  &quot;  null   []  [&quot;&quot;] 
    alert( Number(a1) );  // 0  0  0  0  0

    var a4 =[123]; // [&quot;123&quot;] [1,2,3]
    alert( Number(a4) ); // 123  123  NaN

    var a6；
    alert( Number(a6) ); // NaN

    var a7=function()&#123;alert(0)&#125;; // &#123;abc:123&#125;
    alert( Number(a7) );     // NaN  NaN
</code></pre>
<h3 id="1-2-Number属性"><a href="#1-2-Number属性" class="headerlink" title="1.2 Number属性"></a>1.2 Number属性</h3><pre><code>constructor         返回对创建此对象的 Number 函数的引用。
prototype           使您有能力向对象添加属性和方法。
MAX_VALUE　　       返回能表示的最大数字。
MIN_VALUE　　       能表示的最小数字。
NaN　　　　　　      非数字值。
NEGATIVE_INFINITY　　负无穷，当溢出时返回。
POSITIVE_INFINITY　　正无穷，当溢出时返回。
</code></pre>
<h3 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h3><pre><code>.toString()　　 将 Number 转换为字符串。
.toPrecision(num)　　在 Number 超出指定位数时，将其转换为指数计数法。
.toFixed(num)　　　　把 Number 四舍五入为指定小数位数的数字
.valueOf()　　　　   返回一个Number对象的原始值。
.toExponential(num)　　将 Number 转换为字符串，使用指定数目的有效数字。
</code></pre>
<p>　　</p>
<h2 id="2-String类型"><a href="#2-String类型" class="headerlink" title="2 String类型"></a>2 String类型</h2><pre><code>字符串转换：
    String()    适用于任何数据类型（null,undefined 转换后为null和undefined）；
    toString() （null,defined没有toString()方法）
</code></pre>
<h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre><code>new String(s);  //返回一个新创建的 String 对象，存放的是字符串 s 
String(s);      //只把 s 转换成原始的字符串，并返回转换后的值
</code></pre>
<h3 id="2-2-String属性"><a href="#2-2-String属性" class="headerlink" title="2.2 String属性"></a>2.2 String属性</h3><pre><code>length        字符串的长度
constructor   对创建该对象的函数的引用
prototype     允许您向对象添加属性和方法
</code></pre>
<h3 id="2-3-常用方法"><a href="#2-3-常用方法" class="headerlink" title="2.3 常用方法"></a>2.3 常用方法</h3><pre><code>charAt()
charCodeAt()
concat() 
fromCharCode() 
indexOf()和lastIndexOf()
match()
replace()
search()
slice()
split() 
substr()
substring()
toLocaleUpperCase() / toLocaleLowerCase() /toUpperCase() / toLowerCase()
</code></pre>
<h4 id="1、-charAt-index-返回指定位置的字符"><a href="#1、-charAt-index-返回指定位置的字符" class="headerlink" title="1、 charAt(index)      返回指定位置的字符"></a>1、 charAt(index)      返回指定位置的字符</h4><pre><code>注意：index 在 0 ~ str.length-1 ，若index在范围之外，则返回 &quot;&quot;
    str.charAt()即不带参数 和 str.charAt(NaN) 均返回字符串的第一个字符
</code></pre>
<h4 id="2、-charCodeAt-index-返回在指定的位置的字符的-Unicode-编码"><a href="#2、-charCodeAt-index-返回在指定的位置的字符的-Unicode-编码" class="headerlink" title="2、 charCodeAt(index)       返回在指定的位置的字符的 Unicode 编码"></a>2、 charCodeAt(index)       返回在指定的位置的字符的 Unicode 编码</h4><pre><code>注意：index 在 0 ~ str.length-1 ，若index在范围之外，则返回 NaN
</code></pre>
<h4 id="3、-concat-用于连接两个或多个字符串"><a href="#3、-concat-用于连接两个或多个字符串" class="headerlink" title="3、 .concat()            用于连接两个或多个字符串"></a>3、 .concat()            用于连接两个或多个字符串</h4><h4 id="4、-fromCharCode-接受一个指定的-Unicode-值，然后返回一个字符串。"><a href="#4、-fromCharCode-接受一个指定的-Unicode-值，然后返回一个字符串。" class="headerlink" title="4、 fromCharCode()      接受一个指定的 Unicode 值，然后返回一个字符串。"></a>4、 fromCharCode()      接受一个指定的 Unicode 值，然后返回一个字符串。</h4><pre><code>String.fromCharCode(unicode1,unicode2,...,nuicodeX) 该法是 String 的静态方法，语法应该是 String.fromCharCode()
</code></pre>
<h4 id="5、-indexOf-searchStr-startIndex-返回-searchStr-在字符串中首次出现的位置。匹配不到则返回-1"><a href="#5、-indexOf-searchStr-startIndex-返回-searchStr-在字符串中首次出现的位置。匹配不到则返回-1" class="headerlink" title="5、 indexOf(searchStr,startIndex)          返回 searchStr 在字符串中首次出现的位置。匹配不到则返回-1"></a>5、 indexOf(searchStr,startIndex)          返回 searchStr 在字符串中首次出现的位置。匹配不到则返回-1</h4><h4 id="lastIndexOf-searchStr-startIndex-返回-searchStr-最后出现的位置-从后向前搜索"><a href="#lastIndexOf-searchStr-startIndex-返回-searchStr-最后出现的位置-从后向前搜索" class="headerlink" title="lastIndexOf(searchStr,startIndex)      返回 searchStr 最后出现的位置 从后向前搜索"></a>lastIndexOf(searchStr,startIndex)      返回 searchStr 最后出现的位置 从后向前搜索</h4><h4 id="6、-match-regExp-在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。-匹配不到返回Null"><a href="#6、-match-regExp-在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。-匹配不到返回Null" class="headerlink" title="6、 match(regExp)        在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 匹配不到返回Null"></a>6、 match(regExp)        在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 匹配不到返回Null</h4><pre><code>match()方法返回值为Array类型，
若参数regExp中 没有全局标志&quot;g&quot;: 只查找第一个匹配 
    数组中包括 索引0, 属性index, 属性input
若参数regExp中 有全局标志&quot;g&quot;: 查找所有地匹配 
    其中数组元素就是所有匹配到的子字符串，数组中包括 索引0，索引1，....索引N-1
</code></pre>
<h4 id="7、-replace-regexp-substrOld-replaceStrNew-在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串"><a href="#7、-replace-regexp-substrOld-replaceStrNew-在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串" class="headerlink" title="7、 replace(regexp/substrOld,replaceStrNew)   在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串"></a>7、 replace(regexp/substrOld,replaceStrNew)   在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</h4><h4 id="8、-search-regexp-substr-用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。"><a href="#8、-search-regexp-substr-用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。" class="headerlink" title="8、 search(regexp/substr)    用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。"></a>8、 search(regexp/substr)    用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。</h4><pre><code>返回值：str中第一个与正则或字符串相匹配的子串的起始位置。无匹配返回-1    
说明： search()  不执行全局匹配，它将忽略标志 g。
        总是从字符串的开始进行检索，并返回 stringObject 的第一个匹配的位置
             
</code></pre>
<h4 id="9、-slice-startIndex-endIndex-提取字符串的某个部分，并以新的字符串返回被提取的部分"><a href="#9、-slice-startIndex-endIndex-提取字符串的某个部分，并以新的字符串返回被提取的部分" class="headerlink" title="9、 slice(startIndex,endIndex)     提取字符串的某个部分，并以新的字符串返回被提取的部分"></a>9、 slice(startIndex,endIndex)     提取字符串的某个部分，并以新的字符串返回被提取的部分</h4><pre><code>返回值 [startIndex，endIndex)  前面包括，后面不包括
</code></pre>
<h4 id="10、split-用于把一个字符串分割成字符串数组"><a href="#10、split-用于把一个字符串分割成字符串数组" class="headerlink" title="10、split()    用于把一个字符串分割成字符串数组"></a>10、split()    用于把一个字符串分割成字符串数组</h4><h4 id="11、substr-startIndex-length-抽取从-startIndex-下标开始的指定数目的子串"><a href="#11、substr-startIndex-length-抽取从-startIndex-下标开始的指定数目的子串" class="headerlink" title="11、substr(startIndex,length)   抽取从 startIndex 下标开始的指定数目的子串"></a>11、substr(startIndex,length)   抽取从 startIndex 下标开始的指定数目的子串</h4><pre><code>无参数length，则返回从startIndex到字符串尾字符
</code></pre>
<h4 id="12、substring-startIndex-endIndex-提取字符串中介于两个指定下标之间的子串"><a href="#12、substring-startIndex-endIndex-提取字符串中介于两个指定下标之间的子串" class="headerlink" title="12、substring(startIndex,endIndex)  提取字符串中介于两个指定下标之间的子串"></a>12、substring(startIndex,endIndex)  提取字符串中介于两个指定下标之间的子串</h4><pre><code>无参数endIndex，则返回从startIndex到字符串尾字符
</code></pre>
<h4 id="13、toLocaleUpperCase-toLocaleLowerCase-用于字符串转换大小写（与下面的方法方法仅在某些外国小语种有差别）"><a href="#13、toLocaleUpperCase-toLocaleLowerCase-用于字符串转换大小写（与下面的方法方法仅在某些外国小语种有差别）" class="headerlink" title="13、toLocaleUpperCase() / toLocaleLowerCase()   用于字符串转换大小写（与下面的方法方法仅在某些外国小语种有差别）"></a>13、toLocaleUpperCase() / toLocaleLowerCase()   用于字符串转换大小写（与下面的方法方法仅在某些外国小语种有差别）</h4><h4 id="toUpperCase-toLowerCase-用于字符串转换大小写"><a href="#toUpperCase-toLowerCase-用于字符串转换大小写" class="headerlink" title="toUpperCase() / toLowerCase()   用于字符串转换大小写"></a>toUpperCase() / toLowerCase()   用于字符串转换大小写</h4><h2 id="3-Boolean类型"><a href="#3-Boolean类型" class="headerlink" title="3 Boolean类型"></a>3 Boolean类型</h2><pre><code>该类型只有两个值，true和false
</code></pre>
<h3 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h3><pre><code>new Boolean(value);     
Boolean(value);     
</code></pre>
<h3 id="2-2-String属性-1"><a href="#2-2-String属性-1" class="headerlink" title="2.2 String属性"></a>2.2 String属性</h3><pre><code>constructor   对创建该对象的函数的引用
prototype     允许您向对象添加属性和方法
</code></pre>
<h3 id="2-3-常用方法-1"><a href="#2-3-常用方法-1" class="headerlink" title="2.3 常用方法"></a>2.3 常用方法</h3><pre><code>.toSource()    返回该对象的源代码 
.toString()    把逻辑值转换为字符串，并返回结果 
.valueOf()    返回 Boolean 对象的原始值 
</code></pre>
<h2 id="4-Undefined类型"><a href="#4-Undefined类型" class="headerlink" title="4 Undefined类型"></a>4 Undefined类型</h2><pre><code>只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined
</code></pre>
<h2 id="5-Null类型"><a href="#5-Null类型" class="headerlink" title="5 Null类型"></a>5 Null类型</h2><pre><code>null类型被看做空对象指针，前文说到null类型也是空的对象引用
</code></pre>
<h2 id="6-Object类型"><a href="#6-Object类型" class="headerlink" title="6 Object类型"></a>6 Object类型</h2><pre><code>js中对象是一组属性与方法的集合。
这里就要说到引用类型了，引用类型是一种数据结构，用于将数据和功能组织在一起。
引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法
</code></pre>
<h2 id="三大引用类型"><a href="#三大引用类型" class="headerlink" title="三大引用类型"></a>三大引用类型</h2><h2 id="1-Object类型"><a href="#1-Object类型" class="headerlink" title="1 Object类型"></a>1 Object类型</h2><pre><code>我们看到的大多数类型值都是Object类型的实例，创建Object实例的方式有两种。
    1&gt; 使用new操作符后跟Object构造函数，如下 
        var person = new Object();
        person.name = &quot;Micheal&quot;;
        person.age = 24;
    2&gt; 使用对象字面量表示法，如下 
        var person = &#123;
　　        name : &quot;Micheal&quot;,
　　        age : 24
        &#125;;
</code></pre>
<h2 id="2-Array类型"><a href="#2-Array类型" class="headerlink" title="2 Array类型"></a>2 Array类型</h2><pre><code>数组的每一项可以保存任何类型的数据，比如：字符串，数值，对象....另外，数组的大小是可以动态调整的
</code></pre>
<h3 id="2-1-构造函数-1"><a href="#2-1-构造函数-1" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre><code>创建数组的基本方式有两种:
1&gt; 使用 Array 构造函数：
    var arr1 = new Array(); //创建一个空数组
    var arr2 = new Array(20); // 创建一个包含20项的数组
    var arr3 = new Array(&quot;lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;); // 创建一个包含3个字符串的数组
2&gt; 使用数组字面量表示法：
    var arr4 = []; //创建一个空数组
    var arr5 = [20]; // 创建一个包含1项的数组
    var arr6 = [&quot;lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;]; // 创建一个包含3个字符串的数组
</code></pre>
<h3 id="2-2-Array属性"><a href="#2-2-Array属性" class="headerlink" title="2.2 Array属性"></a>2.2 Array属性</h3><pre><code>length        设置或返回数组中元素的数目
constructor   对创建该对象的函数的引用
prototype     允许您向对象添加属性和方法
</code></pre>
<h3 id="2-3-常用方法-2"><a href="#2-3-常用方法-2" class="headerlink" title="2.3 常用方法"></a>2.3 常用方法</h3><pre><code>join()  
push()和pop() 
shift() 和 unshift() 
sort()
reverse()
concat()
slice()
splice()
indexOf()和 lastIndexOf()
forEach()
map()
filter()
every()
some()
reduce()和 reduceRight()
</code></pre>
<h4 id="1-join"><a href="#1-join" class="headerlink" title="1 join()"></a>1 join()</h4><pre><code>1&gt; join(separator): 以separator为分隔符构成一个字符串，无separator默认用逗号为分隔符，且原数组不变
    var arr = [1,2,3];
    console.log(arr.join()); // 1,2,3
    console.log(arr.join(&quot;-&quot;)); // 1-2-3
    console.log(arr); // [1, 2, 3]（原数组不变）
2&gt; 重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：
    function repeatString(str, n) &#123;
        return new Array(n + 1).join(str);
    &#125;
    console.log(repeatString(&quot;abc&quot;, 3)); // abcabcabc
    console.log(repeatString(&quot;Hi&quot;, 5)); // HiHiHiHiHi
</code></pre>
<h4 id="2-push-和pop-添加-和-移除"><a href="#2-push-和pop-添加-和-移除" class="headerlink" title="2 push()和pop()   添加 和 移除"></a>2 push()和pop()   添加 和 移除</h4><pre><code>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 
pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。

var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
var count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);
console.log(count); // 5
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]
var item = arr.pop();
console.log(item); // Sean
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]
</code></pre>
<h4 id="3-shift-和-unshift-删除-和-添加"><a href="#3-shift-和-unshift-删除-和-添加" class="headerlink" title="3 shift() 和 unshift()  删除 和 添加"></a>3 shift() 和 unshift()  删除 和 添加</h4><pre><code>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined  
unshift():将参数添加到原数组开头，并返回数组的长度 

这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾 

var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
var count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);
console.log(count); // 5
console.log(arr); //[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]
var item = arr.shift();
console.log(item); // Jack
console.log(arr); // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]
</code></pre>
<h4 id="4-sort-升序排列"><a href="#4-sort-升序排列" class="headerlink" title="4 sort()  升序排列"></a>4 sort()  升序排列</h4><pre><code>在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。
即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：
var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];
console.log(arr1.sort()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
arr2 = [13, 24, 51, 3];
console.log(arr2.sort()); // [13, 24, 3, 51]
console.log(arr2); // [13, 24, 3, 51](元数组被改变)

为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。
比较函数接收两个参数，
 如果第一个参数应该位于第二个之前则返回一个负数;
 如果两个参数相等则返回 0;
 如果第一个参数应该位于第二个之后则返回一个正数。
以下就是一个简单的比较函数：
function compare(value1, value2) &#123;
    if (value1 &lt; value2) &#123;
        return -1;
    &#125; else if (value1 &gt; value2) &#123;
        return 1;
    &#125; else &#123;
        return 0;
    &#125;
&#125;
arr2 = [13, 24, 51, 3];
console.log(arr2.sort(compare)); // [3, 13, 24, 51]

如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：
function compare(value1, value2) &#123;
    if (value1 &lt; value2) &#123;
        return 1;
    &#125; else if (value1 &gt; value2) &#123;
        return -1;
    &#125; else &#123;
        return 0;
    &#125;
&#125;
arr2 = [13, 24, 51, 3];
console.log(arr2.sort(compare)); // [51, 24, 13, 3]
</code></pre>
<h4 id="5-reverse-反转数组项顺序"><a href="#5-reverse-反转数组项顺序" class="headerlink" title="5 reverse() 反转数组项顺序"></a>5 reverse() 反转数组项顺序</h4><pre><code>var arr = [13, 24, 51, 3];
console.log(arr.reverse()); //[3, 51, 24, 13]
console.log(arr); //[3, 51, 24, 13](原数组改变)
</code></pre>
<h4 id="6-concat-将参数添加到原数组"><a href="#6-concat-将参数添加到原数组" class="headerlink" title="6 concat()  将参数添加到原数组"></a>6 concat()  将参数添加到原数组</h4><pre><code>这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。
在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。
var arr = [1,3,5,7];
var arrCopy = arr.concat(9,[11,13]);
console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
console.log(arr); // [1, 3, 5, 7](原数组未被修改)

从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。
但是如果传入的是一个二维数组呢？
var arrCopy2 = arr.concat([9,[11,13]]);
console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
console.log(arrCopy2[5]); //[11, 13]
上述arrCopy2数组的第五项是一个包含两项的数组，会把这一数组项当作一项添加到arrCopy2中。
</code></pre>
<h4 id="7-slice-截取数据项-构成新数组"><a href="#7-slice-截取数据项-构成新数组" class="headerlink" title="7 slice() 截取数据项 构成新数组"></a>7 slice() 截取数据项 构成新数组</h4><pre><code>slice(startIndex,endIndex)：返回从原数组中startIndex下标 ~ 结束下标endIndex之间的项组成的新数组 (前闭后开---不包括结束位置的项)
slice(startIndex,)返回从该参数指定位置开始到当前数组末尾的所有项 

    var arr = [1,3,5,7,9,11];
    var arrCopy = arr.slice(1);
    var arrCopy2 = arr.slice(1,4);
    var arrCopy3 = arr.slice(1,-2);
    var arrCopy4 = arr.slice(-4,-1);
    console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
    console.log(arrCopy); //[3, 5, 7, 9, 11]
    console.log(arrCopy2); //[3, 5, 7]
    console.log(arrCopy3); //[3, 5, 7]
    console.log(arrCopy4); //[5, 7, 9]
</code></pre>
<h4 id="8-splice-删除、插入和替换"><a href="#8-splice-删除、插入和替换" class="headerlink" title="8 splice()   删除、插入和替换"></a>8 splice()   删除、插入和替换</h4><pre><code>有很多种用法，可以实现删除、插入和替换。

删除：指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。
插入：提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。
替换：指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
    例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。

splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。

var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr); //[5, 7, 9, 11]
console.log(arrRemoved); //[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr); // [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2); // []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3); //[7]
</code></pre>
<h4 id="9-indexOf-和-lastIndexOf-查找并返回索引"><a href="#9-indexOf-和-lastIndexOf-查找并返回索引" class="headerlink" title="9 indexOf()和 lastIndexOf()  查找并返回索引"></a>9 indexOf()和 lastIndexOf()  查找并返回索引</h4><pre><code>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 
lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。

这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。
var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); //2
console.log(arr.lastIndexOf(5)); //5
console.log(arr.indexOf(5,2)); //2
console.log(arr.lastIndexOf(5,4)); //2
console.log(arr.indexOf(&quot;5&quot;)); //-1
</code></pre>
<h4 id="10-forEach-遍历"><a href="#10-forEach-遍历" class="headerlink" title="10 forEach()  遍历"></a>10 forEach()  遍历</h4><pre><code>对数组进行遍历循环，对数组中的每一项运行给定函数。
这个方法没有返回值。
参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。
    var arr = [1, 2, 3, 4, 5];
    arr.forEach(function(x, index, a)&#123;
    console.log(x + &#39;|&#39; + index + &#39;|&#39; + (a === arr));
    &#125;);
    // 输出为：
    // 1|0|true
    // 2|1|true
    // 3|2|true
    // 4|3|true
    // 5|4|true
</code></pre>
<h4 id="11-map-映射"><a href="#11-map-映射" class="headerlink" title="11 map()   映射"></a>11 map()   映射</h4><pre><code>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。

下面代码利用map方法实现数组中每个数求平方。
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item)&#123;
return item*item;
&#125;);
console.log(arr2); //[1, 4, 9, 16, 25]
</code></pre>
<h4 id="12-filter-过滤"><a href="#12-filter-过滤" class="headerlink" title="12 filter()  过滤"></a>12 filter()  过滤</h4><pre><code>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) &#123;
return index % 3 === 0 || x &gt;= 8;
&#125;); 
console.log(arr2); //[1, 4, 7, 8, 9, 10]
</code></pre>
<h4 id="13-every"><a href="#13-every" class="headerlink" title="13 every()"></a>13 every()</h4><pre><code>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) &#123;
return x &lt; 10;
&#125;); 
console.log(arr2); //true
var arr3 = arr.every(function(x) &#123;
return x &lt; 3;
&#125;); 
console.log(arr3); // false
</code></pre>
<h4 id="14-some"><a href="#14-some" class="headerlink" title="14 some()"></a>14 some()</h4><pre><code>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) &#123;
return x &lt; 3;
&#125;); 
console.log(arr2); //true
var arr3 = arr.some(function(x) &#123;
return x &lt; 1;
&#125;); 
console.log(arr3); // false
</code></pre>
<h4 id="15-reduce-和-reduceRight-迭代遍历"><a href="#15-reduce-和-reduceRight-迭代遍历" class="headerlink" title="15 reduce()和 reduceRight()   迭代遍历"></a>15 reduce()和 reduceRight()   迭代遍历</h4><pre><code>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。
都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。

reduce()方法从数组的第一项开始，逐个遍历到最后。reduceRight()则从数组的最后一项开始，向前遍历到第一项。

传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。
这个函数返回的任何值都会作为第一个参数自动传给下一项。
第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

用reduce()实现数组求和，数组一开始加了一个初始值10 
    var values = [1,2,3,4,5];
    var sum = values.reduceRight(function(prev, cur, index, array)&#123;
    return prev + cur;
    &#125;,10);
    console.log(sum); //25
</code></pre>
<h2 id="3-Function类型"><a href="#3-Function类型" class="headerlink" title="3 Function类型"></a>3 Function类型</h2><pre><code>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。
    函数通常是 使用函数声明语法定义：
    function sum(num1,num2)&#123;
　　    return num1 + num2;
    &#125;;
    也可以使用函数表达式定义函数：
    var sun = function ()&#123;
        return sum1 + sum2;
    &#125;;
</code></pre>
<h4 id="js按照存储方式分为值类型和引用类型。那么他们的计算有什么区别呢？"><a href="#js按照存储方式分为值类型和引用类型。那么他们的计算有什么区别呢？" class="headerlink" title="js按照存储方式分为值类型和引用类型。那么他们的计算有什么区别呢？"></a>js按照存储方式分为值类型和引用类型。那么他们的计算有什么区别呢？</h4><pre><code>题目1： var a = 100;
　　　　var b = a;
　　　   a = 200;
　　　　console.log (b);   //100
题目2： var a = &#123;age : 20&#125;;
　　　　var b = a;
　　　　b.age = 21;
　　　　console.log (a.age); //21
解析：题目1是简单的值类型，在从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上。
此时，a中保存的值为 100 ，用 a 初始化 b ，b保存的值100，但b中的100与a中的是完全独立的，该值只是a中的值的一个副本，
此后，这两个变量可以参加任何操作而相互不受影响。
</code></pre>
<h4 id="也就是说基本类型在赋值操作后，两个变量是相互不受影响的。"><a href="#也就是说基本类型在赋值操作后，两个变量是相互不受影响的。" class="headerlink" title="也就是说基本类型在赋值操作后，两个变量是相互不受影响的。"></a>也就是说基本类型在赋值操作后，两个变量是相互不受影响的。</h4><pre><code>题目2是引用类型，当从一个变量向另一个变量赋值引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。
这时保存在变量中的是对象在堆内存中的地址，所以与简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。
那么赋值操作后，两个变量都保存了同一个对象地址，则这两个变量指向了同一个对象。
因此，改变其中任何一个变量，都会相互影响。
</code></pre>
<h4 id="因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。"><a href="#因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。" class="headerlink" title="因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。"></a>因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。</h4><h3 id="3-1-顶层函数（全局函数）"><a href="#3-1-顶层函数（全局函数）" class="headerlink" title="3.1 顶层函数（全局函数）"></a>3.1 顶层函数（全局函数）</h3><p>全局属性和函数可用于所有内建的 JavaScript 对象 </p>
<h4 id="1、-decodeURI-解码某个编码的-URI"><a href="#1、-decodeURI-解码某个编码的-URI" class="headerlink" title="1、  decodeURI() 解码某个编码的 URI"></a>1、  decodeURI() 解码某个编码的 URI</h4><pre><code>var test1=&quot;http://www.w3school.com.cn/My first/&quot;
document.write(encodeURI(test1)+ &quot;&lt;br /&gt;&quot;)  //  http://www.w3school.com.cn/My%20first/
document.write(decodeURI(test1))   //   http://www.w3school.com.cn/My first/
</code></pre>
<h4 id="2、-decodeURIComponent-解码一个编码的-URI-组件"><a href="#2、-decodeURIComponent-解码一个编码的-URI-组件" class="headerlink" title="2、  decodeURIComponent()         解码一个编码的 URI 组件"></a>2、  decodeURIComponent()         解码一个编码的 URI 组件</h4><h4 id="3、-encodeURI-把字符串编码为-URI"><a href="#3、-encodeURI-把字符串编码为-URI" class="headerlink" title="3、  encodeURI()                     把字符串编码为 URI"></a>3、  encodeURI()                     把字符串编码为 URI</h4><h4 id="4、-encodeURIComponent-把字符串编码为-URI-组件"><a href="#4、-encodeURIComponent-把字符串编码为-URI-组件" class="headerlink" title="4、  encodeURIComponent()         把字符串编码为 URI 组件"></a>4、  encodeURIComponent()         把字符串编码为 URI 组件</h4><h4 id="5、-escape-对字符串进行编码"><a href="#5、-escape-对字符串进行编码" class="headerlink" title="5、  escape()                     对字符串进行编码"></a>5、  escape()                     对字符串进行编码</h4><pre><code>document.write(escape(&quot;Visit W3School!&quot;) + &quot;&lt;br /&gt;&quot;)  //  Visit%20W3School%21
document.write(escape(&quot;?!=()#%&amp;&quot;))  //  %3F%21%3D%28%29%23%25%26
</code></pre>
<h4 id="6、-eval-计算-JavaScript-字符串，并把它作为脚本代码来执行"><a href="#6、-eval-计算-JavaScript-字符串，并把它作为脚本代码来执行" class="headerlink" title="6、  eval()                         计算 JavaScript 字符串，并把它作为脚本代码来执行"></a>6、  eval()                         计算 JavaScript 字符串，并把它作为脚本代码来执行</h4><pre><code>eval(&quot;x=10;y=20;document.write(x*y)&quot;)  //200
document.write(eval(&quot;2+2&quot;))   //4
var x=10
document.write(eval(x+17))   //27
</code></pre>
<h4 id="7、-getClass-返回一个-JavaObject-的-JavaClass"><a href="#7、-getClass-返回一个-JavaObject-的-JavaClass" class="headerlink" title="7、  getClass()                     返回一个 JavaObject 的 JavaClass"></a>7、  getClass()                     返回一个 JavaObject 的 JavaClass</h4><h4 id="8、-isFinite-检查某个值是否为有穷大的数"><a href="#8、-isFinite-检查某个值是否为有穷大的数" class="headerlink" title="8、  isFinite()                     检查某个值是否为有穷大的数"></a>8、  isFinite()                     检查某个值是否为有穷大的数</h4><h4 id="9、-isNaN-检查某个值是否是数字"><a href="#9、-isNaN-检查某个值是否是数字" class="headerlink" title="9、  isNaN()                         检查某个值是否是数字"></a>9、  isNaN()                         检查某个值是否是数字</h4><h4 id="10、-Number-把对象的值转换为数字"><a href="#10、-Number-把对象的值转换为数字" class="headerlink" title="10、  Number()                     把对象的值转换为数字"></a>10、  Number()                     把对象的值转换为数字</h4><pre><code>var test1= new Boolean(true);
var test2= new Boolean(false);
var test3= new Date();
var test4= new String(&quot;999&quot;);
var test5= new String(&quot;999 888&quot;);
document.write(Number(test1)+ &quot;&lt;br /&gt;&quot;);  //1
document.write(Number(test2)+ &quot;&lt;br /&gt;&quot;);  //0
document.write(Number(test3)+ &quot;&lt;br /&gt;&quot;);  //1256657776588
document.write(Number(test4)+ &quot;&lt;br /&gt;&quot;);  //999
document.write(Number(test5)+ &quot;&lt;br /&gt;&quot;);  //NaN
</code></pre>
<h4 id="11、-parseFloat-解析一个字符串并返回一个浮点数"><a href="#11、-parseFloat-解析一个字符串并返回一个浮点数" class="headerlink" title="11、  parseFloat()                 解析一个字符串并返回一个浮点数"></a>11、  parseFloat()                 解析一个字符串并返回一个浮点数</h4><pre><code>document.write(parseFloat(&quot;10&quot;))     // 10
document.write(parseFloat(&quot;10.00&quot;))  // 10
document.write(parseFloat(&quot;10.33&quot;))   // 10.33
document.write(parseFloat(&quot;34 45 66&quot;))   // 34
document.write(parseFloat(&quot; 60 &quot;))    // 60
document.write(parseFloat(&quot;40 years&quot;))  // 40
document.write(parseFloat(&quot;He was 40&quot;))  // NaN
</code></pre>
<h4 id="12、-parseInt-解析一个字符串并返回一个整数"><a href="#12、-parseInt-解析一个字符串并返回一个整数" class="headerlink" title="12、  parseInt()                     解析一个字符串并返回一个整数"></a>12、  parseInt()                     解析一个字符串并返回一个整数</h4><pre><code>parseInt(&quot;10&quot;);            //返回 10
parseInt(&quot;19&quot;,10);        //返回 19 (10+9)
parseInt(&quot;11&quot;,2);        //返回 3 (2+1)
parseInt(&quot;17&quot;,8);        //返回 15 (8+7)
parseInt(&quot;1f&quot;,16);        //返回 31 (16+15)
parseInt(&quot;010&quot;);        //未定：返回 10 或 8
</code></pre>
<h4 id="13、-String-把对象的值转换为字符串"><a href="#13、-String-把对象的值转换为字符串" class="headerlink" title="13、  String()                     把对象的值转换为字符串"></a>13、  String()                     把对象的值转换为字符串</h4><pre><code>var test1= new Boolean(1);
var test2= new Boolean(0);
var test3= new Boolean(true);
var test4= new Boolean(false);
var test5= new Date();
var test6= new String(&quot;999 888&quot;);
var test7=12345;
document.write(String(test1)+ &quot;&lt;br /&gt;&quot;);  // true
document.write(String(test2)+ &quot;&lt;br /&gt;&quot;);  //  false
document.write(String(test3)+ &quot;&lt;br /&gt;&quot;);  // true
document.write(String(test4)+ &quot;&lt;br /&gt;&quot;);  // false
document.write(String(test5)+ &quot;&lt;br /&gt;&quot;);  //  Wed Oct 28 00:17:40 UTC+0800 2009
document.write(String(test6)+ &quot;&lt;br /&gt;&quot;);  // 999 888
document.write(String(test7)+ &quot;&lt;br /&gt;&quot;);  //  12345 
</code></pre>
<h4 id="14、-unescape-对由-escape-编码的字符串进行解码。"><a href="#14、-unescape-对由-escape-编码的字符串进行解码。" class="headerlink" title="14、  unescape()                     对由 escape() 编码的字符串进行解码。"></a>14、  unescape()                     对由 escape() 编码的字符串进行解码。</h4>]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
